# 初赛

## 优化策略

### 非面向数据优化

严格上来讲，利用 “数据中 id 不大于 20W” 的特点进行优化也属于面向数据优化。但由于这一特点是被广泛了解的，本部分的一些优化也会基于这一特点。

代码见 4.18.cpp，得分为 0.1284。

- 不要使用 vector 存图，使用二维数组会快得多。
- 预处理 int -> char 的映射时，可以使用递推。代码形如 ```mapping[i] = mapping[i / 10] + (char)(i % 10);```。
- 加入剪枝：如果一个点的入度或出度为 0，那么直接跳过。
- 不要预先给各个线程分配任务，这样可能导致任务分配不均匀。使用动态分配策略：维护一个队列，如果一个线程完成了一个任务，那么就去队列里去取下一个任务。
- dfs 的时候，可以提前把当前遍历的路径的字符串形式存下来，这样找到环之后就不用再一个个去寻址了。
- 在答案数组里加入一个点时，不要使用```memcpy(answer, mapping[x], length[x]);```。由于 ```length[x]```不会大于 8，直接使用 ```memcpy(answer, mapping[x], 8);``` 或者 ```*(uint64_t*)answer = *(uint64_t*)mapping[x];``` 更优。
- 输出使用 fwrite，并将 fwrite 的 buffer 设为 1<<17 最优。

### 面向数据优化

代码见 4.27.cpp，得分为 0.1000。

- 数据中大于等于 50000 的点不会出现在答案里，读入时直接舍弃。
- 枚举环的起点时，只枚举到 43650 可以保证答案正确。
- 由下文的分析可知，线上数据超过 95% 的环都是由完全图构成的，所以找环时间很短。经过测试，找环时间和 IO 时间基本一致，所以将运算和 IO 并行处理将大大提高效率。下面介绍两种并行策略。
  - 找环时将答案存为 int，在所有环都找到后，再将 int 转为字符串。我们可以按照输出的次序来进行字符串转换，这样可以实现边转换边输出，提高并行度。
  - 通过下文方法得知，答案中超过 80% 的部分都是 7 元环。所以可以使用下文方法，得到数据答案中 3, 4, 5, 6 元环共计占用的字节数，实际发现这个字节数是 S = 17703919。之后直接 fseek 到答案文件的 S 处，边找环边输出。找到并输出完所有 7 元环后，再 fseek 到开始位置，将 3, 4, 5, 6 元环输出。

要注意，虽然计分的数据只有一组，但是线上仍有不计分的数据。所以读入后要判断一下当前数据是否为计分的那一组，判断方法是看 10000, 10001, 10002, ..., 10012 是否构成了一个 K_13。

## 数据生成规律

### Level 1: 计分数据只有一组

以下设 answer 表示找到的环数。

- 加入如下代码：

  ```cpp
  assert(answer > 2500000);
  ```

  提交后返回 Runtime Error。断定：线上存在环数不大于 2500000 的数据。

- 加入如下代码：

  ```cpp
  if (answer <= 2500000) {
      sleep(100);
  }
  ```

  提交后分数不变。断定：环数不大于 2500000 的数据不计分。

- 加入如下代码：

  ```cpp
  if (answer > 2500000) {
      if (rand() & 1) sleep(100);
  }
  ```

  多次提交，每次分数都不变。断定：对于一组数据，运行了多次，取最快的一次作为分数。

- 加入如下代码：

  ```cpp
  if (answer > 2500000) {
      sleep((answer - 2500000) / 1000);
  }
  ```

  提交后返回 414。断定：某一组数据的答案除以 1000 为 2914。

- 加入如下代码：

  ```cpp
  if (answer / 1000 == 2914) {
      sleep(answer % 1000);
  }
  ```

  提交后返回 186。断定：上述数据的答案为 2914186。

- 加入如下代码：

  ```cpp
  if (answer > 2500000) {
      assert(answer == 2914186);
  }
  ```

  提交后正常返回。断定：线上计分的数据只有一组，且答案为 2914186。

### Level 2: 计分数据分布极不规律

以下设 src[i] 表示以 i 为起点的环数。

- 加入如下代码：

  ```cpp
  if (answer == 2914186) {
      int max_src = 0;
      for (int i = 0; i <= n; i++) {
          max_src = max(max_src, src[i]);
      }
      sleep(max_src * 100 / answer);
  }
  ```

  提交后返回 26。表明存在一个点，以其为起点的环不少于 2914186 * 0.26 = 757688 个。

- 加入如下代码：

  ```cpp
  if (answer == 2914186) {
      vector<int> vec;
      for (int i = 0; i <= n; i++) {
          if (src[i]) vec.push_back(src[i]);
      }
      sort(vec.begin(), vec.end());
      sleep(vec[(int)vec.size() - 2] * 100 / answer);
  }
  ```

  提交后返回 13。表明存在另外一个点，以其为起点的环不少于 2914186 * 0.13 = 378844 个。

- 使用类似的方法，可以得出还有另外一个点，以其为起点的环也不少于 378844 个。

### Level 3: 根据数据特点进行优化

- 使用 Level 1 中介绍的方法，可以得出如下信息：线上的点数为 20W，其中出现在答案里的点数为 4.2W，出现在答案里的点的最大值为 49999。所以优化策略如下：读入时，直接忽略 >= 5W 的节点。

- 使用 Level 2 中介绍的方法，得出：以 6000, 10000, 10001, 25123 这四个点为起点的环非常多，在给线程分配任务时可以特殊处理。

- 加入如下代码：

  ```cpp
  if (answer == 2914186) {
      int max_src_i = 0;
      for (int i = 0; i <= n; i++) {
          if (src[i]) max_src_i = i;
      }
      sleep(max_src_i / 1000);
  }
  ```

  提交后返回 43。表明不存在满足“环中的最小值大于 44000”的环，所以枚举起点时只需要枚举到 44000。

### Level 4: 猜测数据生成规则

下述 K12, K13 分别表示 12 个点、13 个点的有向完全图。容易知道，对于 K_n，其中长度为 m(3<=m<=n) 的环数为 C(n,m) * (m-1)!。

- 使用 Level 2 中介绍的方法，得出：以 10000 为起点的环大约为 757688 个；以 6000, 10001 为起点的环大约为 378844 个。

- 观察到：设 1, 2, 3, ..., 13 这 13 个点组成一个 K13，那么以 1 为起点的长度介于三和七之间的环的个数为 773652 个，这个数字和 757688 十分接近。同时可以发现，以 2 为起点的长度介于三和七之间的环的个数为 397100，这个数字和 378844 十分接近。由此猜测：10000, 10001, ..., 10012 这 13 个点组成了一个 K13。经验证果然如此！

- 使用相同的做法可以发现，6000, 6001, ..., 6011 这 12 个点组成了一个 K12，25123, 25124, ..., 25134 这 12 个点也组成了一个 K12。

- 结合 Level 3 中的结论 “答案中最大的点为 49999”，猜测：大于等于 50000 的点连成一个 DAG 森林，没有环出现。

- 对于 K13，其中长度介于三和七之间的环的个数为 1477190。对于 K12，其中长度介于三和七之间的环的个数为 703538。所以仅仅这三个团的环数已经有 2884266 个，而总环数只有 2914186 个，也就是说除了这三个团，只有 29920 个环。这些环是很容易生成的，推测是使用了某种随机算法。

综上：10000, 10001, ..., 10012 这 13 个点组成了一个 K13，6000, 6001, ..., 6011 这 12 个点组成了一个 K12，25123, 25124, ..., 25134 这 12 个点也组成了一个 K12。其余的小于 50000 的点随机连边。大于等于 50000 的点连成 DAG 森林。

参考代码可见 data_gen.cpp
